#include <ros/ros.h>
#include <geometry_msgs/PoseStamped.h>
#include <geometry_msgs/Twist.h>
#include <tf/transform_datatypes.h>
#include <math.h>

/////////////////////////////// Position and Velocity Variables Initialization
double pos_x = 0, pos_y = 0, pos_z = 0, vel_x = 0.0, vel_y = 0.0, vel_the = 0.0;
double pos_x_ant =0.0, pos_y_ant = 0.0, pos_the_ant = 0.0;
/////////////////////////////// Control and Quaternion Variables Initialization
double error_the=0.000001, error_x=0.000001, error_y=0.000001,utheta = 0.0, ux = 0.0, uy = 0.0, o_x, o_y, o_z, o_w=1.0;
float kp_x = 0.15, kd_x = 0.02, kp_y = 0.15, kd_y = 0.02;
float kp = 0.015, kd=0.004;
double roll=0.0,pitch=0.0,yaw=0.0, skid=0.0;
//double alpha1 = 3, alpha2 = 20;
//float k11 = 3.1, k12 = 2.9, k21 = 0.25, k22 = 1.2;
/////////////////////////////// Observer Gain Variables Initialization
float k11, k12, k21, k22;
float phi11, phi12, phi21, phi22;
/////////////////////////////// Constants and TIme Variables Initialization
float pi = 3.14159, t = 0;

void pose_rob(const geometry_msgs::PoseStamped::ConstPtr& msg)
{
        pos_x = msg->pose.position.x;
        pos_y = msg->pose.position.z;// y is z because of the Optitrack calibration
        pos_z = msg->pose.position.y;// z is y because of the Optitrack calibration
        o_x = msg->pose.orientation.x;
        o_y = msg->pose.orientation.y;
        o_z = msg->pose.orientation.z;
        o_w = msg->pose.orientation.w;
}
////funcion saturacion//////
static float sat(float a, float b, float c){
    if(a>=b) a=b;
      else a=a;
      if(a <= c) a=c;
      else a=a;
    return a;
}

////function sign////////
static float sign(float a){
    if(a>0) a=1.0;
      else a=0;
      if(a < 0) a=-1.0;
      else a=0;
    return a;
}

////normalization [0, 360]
double norm360(double x){
    x = fmod(x, 360);
    if (x < 0)
        x += 360;
    return x;
}
//deg -= 360. * std::floor(deg * (1. / 360.));

////normalization [-180, 180]
double norm180(double x){
    x = fmod(x + 180, 360);
    if (x < 0)
        x += 360;
    return x - 180;
}
//deg -= 360. * std::floor((deg + 180.) * (1. / 360.));

int main(int argc, char **argv)
{
    ros::init(argc, argv, "ctrl_node");
    ros::NodeHandle nh;

/////////////////////////////// Subscriber
    // Subscribe to the Optitrack pose publing node
    ros::Subscriber pose_sub = nh.subscribe<geometry_msgs::PoseStamped>("/vrpn_client_node/Robot_1/pose", 20, pose_rob);

/////////////////////////////// Publisher 
    ros::Publisher pub_ang = nh.advertise<geometry_msgs::Twist>("/angulo",50);
    ros::Publisher pub_ctrl = nh.advertise<geometry_msgs::Twist>("/cmd_vel",50);
    //The setpoint publishing rate MUST be faster than 2Hz
    ros::Rate rate(10.0);
    // Wait for FCU connection
    float dt = 0.1;
	
/////////////////////////////// TF from Quaternions to Euler angles
        tf::Quaternion q(o_x,o_y,o_z,o_w);
        tf::Matrix3x3 m(q);
        m.getRPY(roll,pitch,yaw);
/////////////////////////////// Create Angles message
        geometry_msgs::Twist ang;
	
	//ang.header.stamp = ros::Time::now();
	ang.angular.x = roll*(180/M_PI);
	ang.angular.y = pitch*(180/M_PI);
	ang.angular.z = yaw*(180/M_PI);

/////////////////////////////// Create Desired Position message
    geometry_msgs::PoseStamped des;

    // Desired Positions
//    des.pose.position.x = 0.5;// x Desired Position
    //des.pose.position.x = r*cos()

//    des.pose.position.y = -0.5;// y Desired Position
    //des.pose.position.y = r*sin()

    des.pose.position.z = 0.0;// z Desired Position
    // Desired Velocities
    des.pose.orientation.x = 0.0;// x Desired Velocity

    des.pose.orientation.y = 0.0;// y Desired Velocity
/////////////////////////////// Create Control signal message
    geometry_msgs::Twist ctrl;
	ctrl.linear.x = 0;
    	ctrl.linear.y = 0;
    	ctrl.angular.z = 0;
	
 //send a few setpoints before starting
    for(int i = 100; ros::ok() && i > 0; --i)
    {
        pub_ctrl.publish(ctrl);
        
	m.getRPY(roll,pitch,yaw);
	// Velocities
	vel_x = (pos_x - pos_x_ant)/dt;
	pos_x_ant = pos_x;

	vel_y = (pos_y - pos_y_ant)/dt;
	pos_y_ant = pos_y;
	
	vel_the =sat( (roll*(180/M_PI) - pos_the_ant)/dt,1.4,-1.4);
	pos_the_ant = roll*(180/M_PI);
       //ROS_INFO("Husarion o_x: %.3f\t o_y: %.3f\t o_z: %.3f\t o_w:%.3f\n",o_x,o_y,o_z,o_w);
	ROS_INFO("Husarion v_x: %.3f\t v_y: %.3f\t v_the: %.3f\t roll:%.3f\n",vel_x,vel_y,vel_the,roll);
        ros::spinOnce();
        rate.sleep();
    }
/////////////////////////////// Main Loop	
     while(ros::ok())
    {
/////////////////////////////// TF from Quaternions to Euler angles
        tf::Quaternion q(o_x,o_y,o_z,o_w);
        tf::Matrix3x3 m(q);
       
        m.getRPY(roll,pitch,yaw);
/////////////////////////////// Create Angles message
        geometry_msgs::Twist ang;
	
	//ang.header.stamp = ros::Time::now();
	ang.angular.x = roll*(180/M_PI);
	ang.angular.y = pitch*(180/M_PI);
	ang.angular.z = yaw*(180/M_PI);
	
	des.pose.position.x= 0.5;
        des.pose.position.y= 0.5;

        pub_ang.publish(ang);
	
	// Velocities
	vel_x = (pos_x - pos_x_ant)/dt;
	pos_x_ant = pos_x;

	vel_y = (pos_y - pos_y_ant)/dt;
	pos_y_ant = pos_y;
	
	vel_the = sat((roll*(180/M_PI) - pos_the_ant)/dt,1.4,-1.4);
	pos_the_ant = roll*(180/M_PI);

        //HOSM Observer
        //ee1 = z1 - z1h;
        //phi11 = (pow(abs(ee1),(1/2))*sign(ee1)) + alpha1*(pow(abs(ee1),(3,2))*sign(ee1));
        //phi21 = (sign(ee1))/2) + (2*alpha1*ee1) + ((3*pow(alpha1,2))/2)*pow(abs(ee1),2)*sign(ee1);
        //ee2 = z2t - z2h;
        //phi12 = (pow(abs(ee2),(1/2))*sign(ee2)) + aplha2*(pow(abs(ee2),(3,2))*sign(ee2));
        //phi22 = (sign(ee2))/2) +(2*alpha2*ee2) + ((2*pow(alpha2,2))/2)*pow(abs(ee2),2)*sign(ee2);

        // PD Control
    	

        error_x = pos_x-des.pose.position.x;
        error_y = pos_y-des.pose.position.y;
	error_the =roll*(180/M_PI) - atan2(error_x,error_y)*(180/M_PI);
        
 	ux = kp_x*(pos_x-des.pose.position.x)+kd_x*(vel_x-des.pose.orientation.x);
	uy = kp_y*(pos_y-des.pose.position.y)+kd_y*(vel_y-des.pose.orientation.y);
	utheta = kp*(error_the)+kd*(vel_the);

 	if (des.pose.position.x - (abs(pos_x)) < 0 && (des.pose.position.y - abs(pos_y)) < 0){
        skid = -sqrt(pow(ux,2) + pow(uy,2));
	}
	else{
	    skid = sqrt(pow(ux,2) + pow(uy,2));
	}
 
	if (skid <= 0.015 && skid >= -0.015)
	    skid= 0;

    	ctrl.linear.x = skid;//skid//-uy;//uy;
    	ctrl.linear.y = 0;
    	ctrl.angular.z = utheta;//utheta;//utheta
  
        //pose.header.stamp = ros::Time::now();
        
        pub_ctrl.publish(ctrl);
        //ROS_INFO("u_x: %.3f\t uy: %.3f\t E_th: %.3f\t utheta: %.3f\n",ux,uy,error_the,utheta);
	ROS_INFO("u_x: %.3f\t uy: %.3f\t utheta: %.3f\t skid: %.3f\n",ux,uy,utheta,skid);

    //pose.pose.position.x = -3*cos((t2*18/20)*(pi/180))+3;
    //pose.pose.position.y = -3*sin((t2*18/20)*(pi/180));
    //pose.pose.position.z = 3.5;
    t++;

        ros::spinOnce();
        rate.sleep();
    }

    return 0;
}
